                      Mini-projet 1 : solveur DPLL récursif
                             fichier RENDU
                       (à remplir obligatoirement)

**Un mini-projet sans fichier RENDU rempli ne recevra pas de note.**

Date limite: 29 octobre 2021, 23h59

Identité
--------
Nombre de binôme: 64
Nom, prénom 1: Teixeira Medeiros, Claudio
Nom, prénom 2: Maudet, Benjamin


Questions sur votre code
------------------------
0. Avez-vous testé que `make dpll` s'exécute sans erreurs ou warnings,
   et que ensuite `./dpll sudoku-4x4.cnf` donne la réponse attendue (voir
   fichier README) ?

**à remplir**

---

1. Avez-vous utilisé la fonction `filter_map` (donné dans dpll.ml)
   dans votre implémentation de `simplifie` ? 
   - Si oui, expliquez en quelques phrases en français comment vous
     l'avez utilisée.
   - Si non, expliquez en quelques phrases en français comment
     fonctionne votre implémentation de `simplifie`.

Nous avons implementé les deux, mais nous gardons la fonction qui utilise
filter_map, car elle est plus courte et donc plus lisible.

De façon générale:

simplifie(phi, a)
	1 - Enlever !a des clauses dans phi.
	2 - Enlever clauses dans phi où a est positif.
	3 - Retourner phi

De façon spécifique:

Premier cas (sans filter_map):

1 - On définit:
filter_clause clause ret
	Une fonction récursive terminale qui enlève chaque litéral de "clause",

	s'il est différent de !a, filter_clause le rajoute dans "ret". 
	Quand "clause" est vide, filter_clause renvoie ret.

2 - On définit:
filter_cnf clauses ret
	Une fonction récursive terminale qui enlève chaque clause de "clauses". 
	
	Si elle ne contient pas "a", filter_cnf la rajoute dans "ret", si elle 
	contient "!a", filter_cnf appelle "filter_clause" et rajoute son 
	résultat dans "ret". Quand "clauses" est vide, filter_cnf renvoie ret.
	
	
3- On appelle
	"filter_cnf phi []" pour obtenir CNF phi simplifiée et on la retourne.


Deuxième cas (filter_map):

1- On définit:

filter_neg x
	Une fonction qui renvoie None si "x" est égal à !a et "(Some x)" 
	autrement.

2.a- On définit,

i_negless_clauses
	Une formule phi sans !a. 

2.b- En appelant: 
	List.map qui applique à chaque clause de la formule 
	List.filter_map, qui à son tour applique à chaque litéral de la clause
	filter_neg pour renvoyer une liste contenant tous les éléments x.
	
	List.map renvoie ensuite la formule phi sans !a "i_negless_clauses".

3- On définit:

filter clauses ret
	Une fonction récursive terminale qui rajoute les clauses ne contenant
	pas a dans "ret" et qui renvoie "ret".

4- On appelle:

"filter phi []"
	Pour obtenir la formule CNF phi simplifiée et on la retourne.

---

2. Pour l'implémentation de `unitaire`, quelles sont les fonctions
   auxiliaires que vous avez utilisées et/ou écrites ? (Par une
   fonction auxiliaire, on entend ici soit une fonction d'une
   bibliothèque, par exemple des fonctions comme `List.length`,
   `List.rev_append`, ou une fonction `aux_unitaire` que vous avez
   écrite vous-mêmes.) Expliquez en quelques phrases en français
   comment ces fonctions auxiliaires sont utilisées dans votre
   implémentation de la fonction `unitaire`.

**à remplir**

---

3. Pour l'implémentation de `pur`, quelles sont les fonctions
   auxiliaires que vous avez utilisées et/ou écrites ?  Expliquez en
   quelques phrases en français comment ces fonctions auxiliaires sont
   utilisées dans votre implémentation de la fonction `pur`.

**à remplir**

---

4. Donnez un exemple d'une formule pour laquelle les deux fonctions
   `solveur_split` et `solveur_dpll_rec` ont un comportement
   différent, et expliquez les différences entre ces deux fonctions.

**à remplir**

---

5. Avez-vous d'autres remarques sur votre rendu ? (question optionnelle)

**à remplir**

---

--fin du fichier RENDU--
